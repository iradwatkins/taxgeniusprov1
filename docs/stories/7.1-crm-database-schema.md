# Story 7.1: CRM Database Schema & Contact Management

**Epic:** 7 - Native CRM System
**Story Duration:** 5 days
**Story Points:** 8
**Priority:** HIGH (Foundation story - blocks all other CRM stories)
**Status:** In Progress
**Version:** 1.0
**Date:** 2025-01-16

---

## Story Description

As an **admin** or **tax preparer**, I need a centralized contact database that consolidates all clients, leads, affiliates, and preparers with their interaction history, so that I can manage relationships effectively and track all communications in one place.

**Business Value:**
- Centralized view of all contacts (eliminates scattered data)
- Foundation for interaction tracking and pipeline management
- Enables relationship-based workflows
- Supports role-based access control for preparers

---

## Acceptance Criteria

### AC1: Database Schema
- [ ] CRMContact model created with all required fields (firstName, lastName, email, phone, etc.)
- [ ] CRMInteraction model created with support for EMAIL, PHONE_CALL, MEETING, NOTE types
- [ ] CRMStageHistory model created to track pipeline stage changes
- [ ] ContactType enum added (CLIENT, LEAD, AFFILIATE, PREPARER)
- [ ] InteractionType enum added (EMAIL, PHONE_CALL, MEETING, NOTE, OTHER)
- [ ] Direction enum added (INBOUND, OUTBOUND)
- [ ] All foreign keys properly established (userId, assignedPreparerId, contactId)
- [ ] Composite indexes created for performance:
  - `CRMContact`: [email], [assignedPreparerId], [stage], [contactType], [lastContactedAt]
  - `CRMInteraction`: [contactId, occurredAt], [emailThreadId], [type], [userId]
  - `CRMStageHistory`: [contactId, createdAt]

### AC2: Database Migration
- [ ] Prisma migration generated successfully
- [ ] Migration applies cleanly to development database
- [ ] Migration is reversible (all new columns nullable or with defaults)
- [ ] No changes to existing User, Client, Preparer, Affiliate, Lead tables
- [ ] Migration tested in staging environment

### AC3: Data Backfill Script
- [ ] Script creates CRMContact records for all existing Clients
- [ ] Script creates CRMContact records for all existing Leads
- [ ] Script creates CRMContact records for all existing Affiliates
- [ ] Script creates CRMContact records for all existing Preparers
- [ ] Script is idempotent (can run multiple times safely)
- [ ] Script handles edge cases (missing emails, duplicate contacts)
- [ ] Script logs success/failure counts
- [ ] Script runs in < 30 seconds for 1000 contacts

### AC4: CRM Service Layer
- [ ] `CRMService` class created in `lib/services/crm.service.ts`
- [ ] Method: `createContact(data)` - Creates new CRM contact
- [ ] Method: `getContactById(id, userId, userRole)` - Gets contact with auth check
- [ ] Method: `updateContact(id, data, userId, userRole)` - Updates contact with auth check
- [ ] Method: `deleteContact(id, userId, userRole)` - Soft deletes contact
- [ ] Method: `listContacts(filters, pagination, userId, userRole)` - Lists contacts with filters
- [ ] Method: `assignContactToPreparer(contactId, preparerId, assignedBy)` - Assigns preparer
- [ ] Row-level security enforced (preparers see only their assigned contacts)
- [ ] All methods use TypeScript types for inputs/outputs

### AC5: API Endpoints
- [ ] `GET /api/crm/contacts` - List contacts (paginated, filtered)
  - Auth: admin, tax_preparer
  - Query params: page, limit, stage, contactType, assignedPreparerId, search
  - Returns: `{ success: true, data: { contacts: [], total: number, page: number, limit: number } }`
- [ ] `POST /api/crm/contacts` - Create new contact
  - Auth: admin, tax_preparer
  - Body: firstName, lastName, email, phone, contactType, etc.
  - Returns: `{ success: true, data: CRMContact }`
- [ ] `GET /api/crm/contacts/[id]` - Get contact details
  - Auth: admin, tax_preparer (with row-level check)
  - Returns: `{ success: true, data: CRMContact }`
- [ ] `PATCH /api/crm/contacts/[id]` - Update contact
  - Auth: admin, tax_preparer (with row-level check)
  - Body: Partial<CRMContact>
  - Returns: `{ success: true, data: CRMContact }`
- [ ] `DELETE /api/crm/contacts/[id]` - Soft delete contact
  - Auth: admin only
  - Returns: `{ success: true, data: { deleted: true } }`

### AC6: Role-Based Access Control
- [ ] Only super_admin, admin, and tax_preparer roles can access CRM endpoints
- [ ] Tax preparers can only view/edit contacts assigned to them
- [ ] Admins can view/edit all contacts
- [ ] Proper error messages when access denied (403 Forbidden)
- [ ] Auth middleware reuses existing `requireOneOfRoles` pattern

### AC7: Testing
- [ ] Unit tests for CRMService methods (>80% coverage)
- [ ] Integration tests for all API endpoints
- [ ] Test cases for role-based access control
- [ ] Test cases for edge cases (duplicate emails, missing data)
- [ ] All tests pass successfully

### AC8: Backward Compatibility
- [ ] Existing Client/Preparer/Affiliate/Lead queries still work
- [ ] No breaking changes to existing API routes
- [ ] Epic 6 Lead Tracking dashboard still functional
- [ ] No performance degradation in existing features

---

## Technical Implementation Details

### Files to Create

```
prisma/migrations/
└── YYYYMMDDHHMMSS_add_crm_system/
    └── migration.sql

scripts/
└── backfill-crm-contacts.ts

src/lib/services/
└── crm.service.ts

src/app/api/crm/
├── contacts/
│   ├── route.ts              # GET, POST /api/crm/contacts
│   └── [id]/
│       └── route.ts          # GET, PATCH, DELETE /api/crm/contacts/[id]

src/types/
└── crm.ts

src/lib/__tests__/services/
└── crm.service.test.ts

__tests__/api/crm/
└── contacts.test.ts
```

### Prisma Schema Changes

Add to `prisma/schema.prisma`:

```prisma
// CRM Contact (extends existing User/Client/Preparer/Affiliate)
model CRMContact {
  id                String    @id @default(cuid())
  userId            String    @unique  // FK to User table
  contactType       ContactType        // CLIENT | LEAD | AFFILIATE | PREPARER

  // Contact metadata
  firstName         String
  lastName          String
  email             String    @unique
  phone             String?
  company           String?

  // Tax-specific fields
  filingStatus      String?   // Single, Married, etc.
  dependents        Int?
  previousYearAGI   Float?
  taxYear           Int?

  // CRM lifecycle
  stage             PipelineStage @default(NEW)
  stageEnteredAt    DateTime  @default(now())
  source            String?   // utm_source, referral code, etc.

  // Assignment
  assignedPreparerId String?
  assignedAt        DateTime?

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastContactedAt   DateTime?

  // Relations
  user              User      @relation(fields: [userId], references: [id])
  assignedPreparer  Preparer? @relation(fields: [assignedPreparerId], references: [id])
  interactions      CRMInteraction[]
  stageHistory      CRMStageHistory[]

  @@index([email])
  @@index([assignedPreparerId])
  @@index([stage])
  @@index([contactType])
  @@index([lastContactedAt])
}

enum ContactType {
  CLIENT
  LEAD
  AFFILIATE
  PREPARER
}

// CRM Interaction (phone, email, meeting, note)
model CRMInteraction {
  id                String    @id @default(cuid())
  contactId         String
  userId            String    // Who logged this interaction

  // Interaction details
  type              InteractionType
  direction         Direction @default(OUTBOUND) // INBOUND | OUTBOUND
  subject           String?
  body              String?   @db.Text
  duration          Int?      // minutes (for calls/meetings)

  // Email-specific (for Resend sync)
  emailId           String?   @unique // Resend email ID
  emailThreadId     String?   // For Gmail-style threading
  emailTo           String[]
  emailCc           String[]
  emailBcc          String[]

  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  occurredAt        DateTime  @default(now()) // When interaction happened

  // Attachments
  attachments       Json?     // Array of MinIO file keys

  // Relations
  contact           CRMContact @relation(fields: [contactId], references: [id])
  user              User      @relation(fields: [userId], references: [id])

  @@index([contactId, occurredAt(sort: Desc)])
  @@index([emailThreadId])
  @@index([type])
  @@index([userId])
}

enum InteractionType {
  EMAIL
  PHONE_CALL
  MEETING
  NOTE
  OTHER
}

enum Direction {
  INBOUND
  OUTBOUND
}

// Stage history tracking (for reporting)
model CRMStageHistory {
  id                String    @id @default(cuid())
  contactId         String
  fromStage         PipelineStage?
  toStage           PipelineStage
  changedBy         String    // userId
  reason            String?   @db.Text
  createdAt         DateTime  @default(now())

  contact           CRMContact @relation(fields: [contactId], references: [id])

  @@index([contactId, createdAt(sort: Desc)])
}
```

### TypeScript Types

```typescript
// src/types/crm.ts

import { ContactType, InteractionType, Direction, PipelineStage } from '@prisma/client';

export interface CRMContactInput {
  userId: string;
  contactType: ContactType;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  company?: string;
  filingStatus?: string;
  dependents?: number;
  previousYearAGI?: number;
  taxYear?: number;
  source?: string;
  assignedPreparerId?: string;
}

export interface CRMContactUpdate {
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  company?: string;
  filingStatus?: string;
  dependents?: number;
  previousYearAGI?: number;
  taxYear?: number;
  stage?: PipelineStage;
  assignedPreparerId?: string;
}

export interface ContactFilters {
  stage?: PipelineStage;
  contactType?: ContactType;
  assignedPreparerId?: string;
  search?: string; // Search across name, email, phone
}

export interface PaginationParams {
  page?: number;
  limit?: number;
}

export interface CRMContactListResponse {
  contacts: CRMContact[];
  total: number;
  page: number;
  limit: number;
}
```

### CRM Service Implementation

```typescript
// src/lib/services/crm.service.ts

import { prisma } from '@/lib/prisma';
import { ContactType, PipelineStage } from '@prisma/client';
import type { CRMContactInput, CRMContactUpdate, ContactFilters, PaginationParams } from '@/types/crm';

export class CRMService {
  /**
   * Create a new CRM contact
   */
  static async createContact(data: CRMContactInput) {
    const contact = await prisma.cRMContact.create({
      data: {
        ...data,
        stageEnteredAt: new Date(),
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            clerkUserId: true,
          },
        },
        assignedPreparer: {
          select: {
            id: true,
            userId: true,
          },
        },
      },
    });

    return contact;
  }

  /**
   * Get contact by ID with row-level security
   */
  static async getContactById(id: string, userId: string, userRole: string) {
    const contact = await prisma.cRMContact.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            clerkUserId: true,
          },
        },
        assignedPreparer: {
          select: {
            id: true,
            userId: true,
          },
        },
        interactions: {
          orderBy: { occurredAt: 'desc' },
          take: 10,
        },
        stageHistory: {
          orderBy: { createdAt: 'desc' },
          take: 10,
        },
      },
    });

    if (!contact) {
      throw new Error('Contact not found');
    }

    // Row-level security: tax preparers can only see their assigned contacts
    if (userRole === 'tax_preparer') {
      const preparer = await prisma.preparer.findUnique({
        where: { userId },
      });

      if (!preparer || contact.assignedPreparerId !== preparer.id) {
        throw new Error('Access denied: Contact not assigned to you');
      }
    }

    return contact;
  }

  /**
   * Update contact with row-level security
   */
  static async updateContact(
    id: string,
    data: CRMContactUpdate,
    userId: string,
    userRole: string
  ) {
    // Verify access
    await this.getContactById(id, userId, userRole);

    const updatedContact = await prisma.cRMContact.update({
      where: { id },
      data,
      include: {
        user: true,
        assignedPreparer: true,
      },
    });

    return updatedContact;
  }

  /**
   * Soft delete contact (admin only)
   */
  static async deleteContact(id: string) {
    // In production, implement soft delete with deletedAt field
    // For now, we'll just return success
    await prisma.cRMContact.update({
      where: { id },
      data: {
        // Soft delete logic here
      },
    });

    return { deleted: true };
  }

  /**
   * List contacts with filters and pagination
   */
  static async listContacts(
    filters: ContactFilters,
    pagination: PaginationParams,
    userId: string,
    userRole: string
  ) {
    const { page = 1, limit = 50 } = pagination;
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {};

    if (filters.stage) {
      where.stage = filters.stage;
    }

    if (filters.contactType) {
      where.contactType = filters.contactType;
    }

    if (filters.search) {
      where.OR = [
        { firstName: { contains: filters.search, mode: 'insensitive' } },
        { lastName: { contains: filters.search, mode: 'insensitive' } },
        { email: { contains: filters.search, mode: 'insensitive' } },
        { phone: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    // Row-level security: tax preparers see only their assigned contacts
    if (userRole === 'tax_preparer') {
      const preparer = await prisma.preparer.findUnique({
        where: { userId },
      });

      if (preparer) {
        where.assignedPreparerId = preparer.id;
      }
    }

    if (filters.assignedPreparerId) {
      where.assignedPreparerId = filters.assignedPreparerId;
    }

    const [contacts, total] = await Promise.all([
      prisma.cRMContact.findMany({
        where,
        skip,
        take: limit,
        orderBy: { updatedAt: 'desc' },
        include: {
          user: {
            select: {
              id: true,
              email: true,
            },
          },
          assignedPreparer: {
            select: {
              id: true,
              userId: true,
            },
          },
          _count: {
            select: {
              interactions: true,
            },
          },
        },
      }),
      prisma.cRMContact.count({ where }),
    ]);

    return {
      contacts,
      total,
      page,
      limit,
    };
  }

  /**
   * Assign contact to preparer
   */
  static async assignContactToPreparer(
    contactId: string,
    preparerId: string,
    assignedBy: string
  ) {
    const contact = await prisma.cRMContact.update({
      where: { id: contactId },
      data: {
        assignedPreparerId: preparerId,
        assignedAt: new Date(),
      },
      include: {
        assignedPreparer: true,
      },
    });

    return contact;
  }
}
```

---

## Testing Strategy

### Unit Tests

```typescript
// src/lib/__tests__/services/crm.service.test.ts

describe('CRMService', () => {
  describe('createContact', () => {
    it('should create a new CRM contact', async () => {
      // Test implementation
    });

    it('should enforce unique email constraint', async () => {
      // Test implementation
    });
  });

  describe('getContactById', () => {
    it('should return contact for admin', async () => {
      // Test implementation
    });

    it('should return contact for assigned preparer', async () => {
      // Test implementation
    });

    it('should deny access for non-assigned preparer', async () => {
      // Test implementation
    });
  });

  describe('listContacts', () => {
    it('should filter contacts by stage', async () => {
      // Test implementation
    });

    it('should filter contacts by search term', async () => {
      // Test implementation
    });

    it('should paginate results correctly', async () => {
      // Test implementation
    });

    it('should enforce row-level security for preparers', async () => {
      // Test implementation
    });
  });
});
```

### Integration Tests

```typescript
// __tests__/api/crm/contacts.test.ts

describe('GET /api/crm/contacts', () => {
  it('should return contacts for admin', async () => {
    // Test implementation
  });

  it('should return only assigned contacts for preparer', async () => {
    // Test implementation
  });

  it('should deny access for non-CRM roles', async () => {
    // Test implementation
  });
});

describe('POST /api/crm/contacts', () => {
  it('should create contact with valid data', async () => {
    // Test implementation
  });

  it('should reject duplicate email', async () => {
    // Test implementation
  });
});
```

---

## Dependencies & Prerequisites

**Required Before Starting:**
- ✅ Existing Prisma schema and migrations
- ✅ User, Client, Preparer, Affiliate, Lead models
- ✅ PipelineStage enum defined
- ✅ Existing auth middleware (`requireOneOfRoles`)

**External Dependencies:**
- None (pure database/API work)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Database migrations applied successfully
- [ ] Backfill script executed and verified
- [ ] All unit tests passing (>80% coverage)
- [ ] All integration tests passing
- [ ] Code reviewed and approved
- [ ] No breaking changes to existing features
- [ ] Epic 6 regression tests passing
- [ ] Documentation updated

---

## Risk & Mitigation

| Risk | Mitigation |
|------|------------|
| **Duplicate contacts during backfill** | Use email as unique constraint, handle duplicates gracefully |
| **Performance issues with large contact lists** | Implement pagination, add composite indexes, cache frequently accessed data |
| **Breaking Epic 6 functionality** | Run full regression tests, ensure no changes to existing models |
| **Row-level security bugs** | Comprehensive testing of access control logic |

---

## Next Steps After Story 7.1

Once this story is complete:
1. **Story 7.2:** Implement interaction tracking and Resend email sync
2. **Story 7.3:** Build CRM dashboard UI
3. **Story 7.4:** Implement Kanban pipeline board
4. **Story 7.5:** Add relationship tracking and reporting

---

**Story Created:** 2025-01-16
**Story Owner:** Development Agent
**Estimated Completion:** 5 days from start
